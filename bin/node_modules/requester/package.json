{
  "name": "requester",
  "version": "0.1.12",
  "description": "swiss army knife for requests",
  "main": "index.js",
  "directories": {
    "example": "examples",
    "test": "tests"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/icodeforlove/node-requester.git"
  },
  "keywords": [
    "http",
    "https",
    "xml",
    "json",
    "proxies"
  ],
  "author": {
    "name": "Chad Scira"
  },
  "license": "MIT",
  "devDependencies": {
    "async": "0.1.22",
    "vows": "1.2.7"
  },
  "dependencies": {
    "async": "0.1.22",
    "form-data": "0.0.6",
    "underscore": "1.4.0",
    "xml2js": "0.2.0",
    "colors": "0.6.0-1"
  },
  "readme": "## node-requester\n\nA simple network request helper that is geared towards crawling. (a few keywords GZIP, XML, JSON, PROXIES)\n\n## installation\n\n    $ npm install requester\n\n## super simple to use\n\n```javascript\nvar Requester = require('requester'),\n\trequester = new Requester({debug: 1});\n\nrequester.get(/* URL */, function (body) {\n\tconsole.log(this.statusCode, body);\n});\n\nrequester.get(/* URL */, /* REQUEST_OBJECT */, function (body) {\n\tconsole.log(this.statusCode, body);\n});\n```\n\nyou can even use this simple [request translation tool](http://codepen.io/icodeforlove/full/nKuwa)\n\n## initialization\n\n```javascript\nvar Requester = ('requester');\n\nvar requester = new Requester({\n\tcookiejar: true, // basic cookie support, currently doesnt care about domain or path rules\n\tcookies: {},\n\theaders: {},\n\ttimeout: 4000,\n\tretries: 3,\n\tencoding 'utf8',\n\t// didRequestFail: null, (this has its own section)\n\t// signRequest: null, (this has its own section)\n\t// processResponse: null, (this has its own section)\n\tdataType: 'RAW' // JSON or XML,\n\tauth: {username: 'username', password: 'password'}, // basic auth for all requests\n\tproxies: [{ip: '127.0.0.1', port: 1337}, {ip: '127.0.0.2', port: 1337}, {ip: '127.0.0.3', port: 1337}] // rotating proxy array\n});\n```\n\nif you initialize the request object with any of the above properties every request will default to those settings, you can over ride them on a per request basis\n\n```javascript\nvar options = {\n\tencoding: 'binary',\n\tproxy: {ip: '127.0.0.1', port: 1337},\n\tdata: {foo: 'bar'},\n\tcookies: {foo: 'bar'},\n\tauth: {username: 'username', password: 'password'} // basic auth for request\n};\n\nrequester.get(/* URL */, options, function (body) {\n\tconsole.log(body)\n});\n```\n## request objects\n\nthey support the following properties\n* {Object} data \n* {String} dataType\n* {Object} headers\n* {Object} cookies\n* {Object} proxy\n* {Object} auth\n* {String} encoding\n* {Number} timeout\n* {Number} retries\n* {Function} didRequestFail\n* {Function} signRequest\n* {Function} processResponse\n* {Boolean} follow\n* {Number} followMax\n* {Number} debug\n\n## debugging\n\nyou can set debug to the following\n* 1 - outgoing requests \n* 2 - outgoing requests and responses with headers\n* 3 - outgoing requests, responses with headers, and response body\n\n## proxies\n\nrequest objects support proxies but you also can add / remove them from the proxy rotation like this\n\n```javascript\nvar requester = new Requester({\n\tproxies: [{ip: 127.0.0.1, port: 1337}]\n});\n\nrequester.addProxies({ip: 127.0.0.1, port: 1337}, {ip: 127.0.0.2, port: 1337}, {ip: 127.0.0.1, port: 1337, auth: {username: 'foo', password: 'bar'}});\n\nrequester.removeProxies({ip: 127.0.0.1, port: 1337});\n```\n\nthis allows you to do custom checking outside of requester to maintain the proxy list\n\n## request response checking\n\nthis is a method that gets ran before the actual response callback gets run to ensure that the content is what you're expecting, for example if the content rotates and you're looking for something special you can do\n\n```javascript\nrequester.get(\n\t/ * URL */,\n\t{\n\t\tdidRequestFail: function (data) {\n\t\t\treturn !data.match(/something/);\n\t\t},\n\t\tretries: 10\n\t},\n\tfunction (data) {\n\t\tconsole.log(data);\n\t}\n);\n```\n\nthis would request the url until it matches the string 'something' in the response (up to 10 attempts)\n\n## response preprocessing\n\nlets say the server responds back with invalid JSON\n\n```javascript\nvar json = {foo: 'bar'}\n```\nyou can use a processResponse function to clean it up like this\n\n```javascript\nrequester.get(\n\t/* URL */,\n\t{\n\t\tdataType: 'JSON',\n\t\tprocessResponse: function (body) {\n\t\t\treturn body.replace(/^var json = /, '');\n\t\t}\n\t},\n\tfunction (body) {\n\t\tconsole.log(body);\n\t}\n);\n```\n\nthis is really useful if you want to not repeat response cleanup code\n\n## request signatures\n\nyou can create a custom request signature function like this\n\n```javascript\nvar qs = require('querystring');\n\nvar requester = new Requester({\n\tsignRequest: function (data) {\n\t\t// do something with the data\n\t\treturn qs.stringify(data);\n\t}\n});\n```\n\n## posting\n\n```javascript\nrequester.post(/* URL */, {data: {foo: 'bar', bar: 'foo'}}, function (body) {\n\tconsole.log(body)\n});\n```\n\n## multipart\n\nthe multipart request works a little different, in the data object you can prefix a values key with '@' like this\n\n```javascript\nrequester.multipart(/* URL */, {data: {'@file': /* FILEPATH */, '@file2': /* FILEPATH */, bar: 'foo'}}, function (body) {\n\tconsole.log(body)\n});\n```\n\nthis will create a multipart request and upload files\n",
  "_id": "requester@0.1.12",
  "dist": {
    "shasum": "0c79c1fc2919216a3f2f81e7a87c7423df2722b1"
  },
  "_from": "requester@0.1.12"
}
