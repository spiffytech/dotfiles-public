{
  "name": "sqlite-fts",
  "description": "SQLite3 bindings for Node with FTS4 enabled",
  "version": "0.0.9",
  "homepage": "http://github.com/quartzjer/node-sqlite-fts",
  "author": {
    "name": "Jeremie Miller",
    "email": "jeremie@jabber.org"
  },
  "contributors": [
    {
      "name": "Artem Kustikov"
    },
    {
      "name": "Eric Fredricksen"
    },
    {
      "name": "John Wright"
    },
    {
      "name": "Ryan Dahl"
    },
    {
      "name": "Orlando Vazquez",
      "email": "ovazquez@gmail.com",
      "url": "http://2wycked.net"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/quartzjer/node-sqlite-fts.git"
  },
  "main": "./sqlite-fts",
  "engines": {
    "node": ">=0.6.0"
  },
  "scripts": {
    "test": "./run-tests",
    "preinstall": "node-waf configure build"
  },
  "licenses": [
    {
      "type": "BSD"
    }
  ],
  "dependencies": {
    "extend": "1.0.0"
  },
  "devDependencies": {},
  "optionalDependencies": {},
  "readme": "# NAME\n\nnode-sqlite - Asynchronous SQLite3 driver for Node.js\n\nSQLite calls block, so to work around this, synchronous calls happen within\nNode's libeio thread-pool, in a similar manner to how POSIX calls are\ncurrently made.\n\n# SYNOPSIS\n\n## High-level Driver\n\n    var sys    = require('sys'),\n        sqlite = require('sqlite');\n\n    var db = new sqlite.Database();\n\n    // open the database for reading if file exists\n    // create new database file if not\n\n    db.open(\"aquateen.db\", function (error) {\n      if (error) {\n          console.log(\"Tonight. You.\"));\n          throw error;\n      }\n      db.execute\n        ( \"INSERT INTO aqua_teens (name) VALUES (?)\"\n        , ['meaty meaty moo']\n        , function (error, rows) {\n            if (error) throw error;\n            console.log(\"Aqua teen added.\");\n          }\n        );\n      var sql = 'SELECT name FROM dudes WHERE type = ? AND age > ?';\n\n      db.prepare(sql, function (error, statement) {\n        if (error) throw error;\n\n        // Fill in the placeholders\n        statement.bindArray(['milkshake', 30], function () {\n\n          statement.fetchAll(function (error, rows) {\n            // ...\n            statement.finalize(function (error) {\n              console.log(\"All done!\");\n            });\n          });\n        });\n      });\n    });\n\n# API\n\n## Database Objects\n\nTo create a new database object:\n    var sqlite = require('sqlite');\n\n    var db = sqlite.Database();\n\n### database.open(filename, function (error) {})\n\nOpen a database handle to the database at the specified filename. If the file\ndoes not exist the bindings will attempt to create it. The callback takes no\narguments.\n\nA filename of \":memory:\" may be used to create an in-memory database.\n\n### database.close(function (error) {})\n\nClose the database handle.\n\n### database.execute(sql[, bindings], function (error, rows) {})\n\nExecute a SQL query, `sql` with optional bindings `bindings` on the currently\nopened database. The callback will be executed once with all the rows returned\nfor the query. This is much faster than `database.query` since there are less roundtrips into the thread-pool.\n\n### database.query(sql, [bindings,] function (error, row) {})\n\nExecute a SQL query, `sql`, with optional bindings `bindings` on the currently\nopened database. The callback will be executed once per row returned, plus\nonce more with row set to undefined to indicate end of results.\n\n### database.executeScript(SQL, function (error) {});\n\n    db.executeScript\n      (   \"CREATE TABLE table1 (id, name);\"\n        + \"CREATE TABLE table2 (id, age);\"\n        + \"INSERT INTO table1 (1, 'Mister Shake');\"\n        + \"INSER INTO table2 (1, 34);\"\n      , function (error) {\n          if (error) throw error;\n          // ...\n        });\n\nExecute multiple semi-colon separated SQL statements. Statements must take no\nplaceholders. Each statement will be executed with a single step() and then\nreset. This is ideally suited to executing multiple DDL statements.\n\n### database.prepare(SQL, [options,] function (error, statement) {})\n\nCreate a prepared statement from an SQL string. Prepared statements can be\nused used to iterate over results and to avoid compiling SQL each time a query\nis performed.\n\nOptions:\n\n- lastInsertRowID: boolean, default false.\n    If true, when this statement is step()'d over, the context object (this) in\n    the callback will contain a lastInsertRowID member with the ID of the last\n    inserted row.\n\n- affectedRows: boolean, default false.\n    If true, when this statement is step()'d over, the context object (this) in\n    the callback will contain an affectedRows member with the number of\n    affected rows for the last step.\n\n## Statement Objects\n\n### statement.bindArray(array, function (error) {})\n\n    statement.bindArray([1, 'robots', 4.20], callback)\n\nBind array items to place-holder values (? or $foo) in statement.\n\n### statement.bindObject(object, function (error) {})\n\n    statement.bindObject({ $name: 'meatwad',\n                           $occupation: 'Former detective' }, callback)\n\nBind object properties to named place-holder values ($foo, $bar, $baz) in\nstatement.\n\n### statement.bind(position, value, function (error) {})\n\n    statement.bind(1, \"tango\", function (error) {})\n\nBind a value to a place-holder position. Because binding place-holders is done\nby position (not index), the first place-holder is at position 1, second at\nplace-holder position 2, etc.\n\n### statement.clearBindings()\n\nImmediately clear the bindings from the statement. There is no callback.\n\n### statement.step(function (error, row) {})\n\nFetch one row from a prepared statement and hand it off to a callback. If\nthere are no more rows to be fetched, row will be undefined. Rows are\nrepresented as objects with properties named after the respective columns.\n\n### statement.fetchAll(function (error, rows) {})\n\nFetch all rows in statement and pass them to the callback as an array of\nobjects, each object representing one row.\n\n### statement.reset()\n\nImmediately reset a statement object back to it's initial state, ready to be\nstep() or fetchAll()'d again.\n\n### statement.finalize(function (error) {})\n\nFree SQLite objects associated with this statement and mark it for garbage\ncollection.\n\n## Supported Types\n\nAt the moment, the supported types are TEXT, NUMBER, FLOAT and NULL.\n\n# BUILDING\n\nTo obtain and build the bindings:\n\n    git clone http://github.com/orlandov/node-sqlite.git\n    cd node-sqlite\n    node-waf configure build\n\n# TESTS\n\nRunning the unit tests could not be easier. Simply:\n\n    git submodule update --init\n    ./run-tests\n\n# SEE ALSO\n\n* http://sqlite.org/docs.html\n* http://github.com/grumdrig/node-sqlite/\n\n# AUTHORS\n\nOrlando Vazquez [ovazquez@gmail.com]\n\nRyan Dahl [ry@tinyclouds.org]\n\n# THANKS\n\nMany thanks to Eric Fredricksen for his synchronous driver on which this\ndriver was originally based.\n\n* http://github.com/grumdrig/node-sqlite/\n* http://grumdrig.com/node-sqlite/\n\n# LICENSE\n\nnode-sqlite is BSD licensed.\n\n(c) 2010 Orlando Vazquez\n",
  "readmeFilename": "README.md",
  "_id": "sqlite-fts@0.0.9",
  "_from": "sqlite-fts"
}
